A题题意：给你n个数，m个操作，每个操作包含三个数l,r,d，即把第l到第r个数都加上d。接下来我们要对这个数列搞k次事情，每次给出两个数x,y，即执行第x到第y个操作。要求输出所有操作完成之后的数列。
题解：非常弱智的方法……维护两个树状数组，一个维护数列，一个维护操作次数（均为区间修改，单点查询）。每次读入x,y，add1(x,1),add1(y+1,-1)。所有读入完成后，遍历每次操作，修改数列，最后查询。
B题题意：给你一张有n个点的带权有向图，任意两个点之间都有边相连。接下来我们要对这张图做n次操作，每次删除一个点以及与其相连的所有边。要求输出每次操作之前，任意两点之间的最短路之和。
题解：floyd。首先我们知道，floyd算法的本质是dp，最外层的循环k表示最短路中途只经过前k个点。这道题每次删除一个点，那么我们可以倒着做，首先用一个数组b记录每次操作删除的点，然后for(int k=n;k>0;k--),每次将b[k]作为中间点进行最短路计算，并将vis[b[k]]标记为true.调整完最短路之后，遍历每一对点i,j，如果两个点都已被标记成true，则ans+=dis[i][j]。将ans存入数组，最后输出。
C题题意：给你n个人,一部分体重是50，一部分体重是100.有一艘船，只能承受k的重量。每次渡河至少要有一个人在船上。求出要让所有人全部过河，至少需要渡河多少次，次数最小的情况下有多少种不同的方案。
题解：dp。首先统计50kg和100kg的人数，分别记为x和y。开一个数组f1[t][i][j](t∈[0,1])表示船在t岸(0表示没有过河，1表示过了河)，还有i个50kg的人，j个100kg的人没过河，所需的最少次数，用类似于最短路的方法求出答案，输出f1[1][0][0]。之后开一个数组f2[t][i][j]表示船在t岸，还有i个50kg的人，j个100kg的人没过河的总方案数，当f1[t xor 1][p][q]+1=f1[t][i][j]时即可转移，转移方程为:f2[t][i][j]+=f1[t xor 1][p][q]*选择50kg的人方案数*选择100kg的人方案数。最后输出f2[1][0][0]即可。（记得取模）
