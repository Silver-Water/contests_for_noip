A题题意：给你n根蜡烛，每K根烧完的蜡烛可以换一根新的蜡烛，求出最多能烧几根蜡烛。
思路：直接模拟，每次ans+=n,n=n/k+n%k，直到n<k为止。
B题题意：给你n个钱包，每个钱包里要放入a[i]个硬币，你每次可以执行三种操作：左移，右移，放一个硬币，但是不能连续放两个硬币，也不能走出[1,n]的范围。输出任意一种操作序列。
思路：本题spj很强大，直接模拟即可。对于第1到第n-1个钱包，重复放硬币、右移。左移的操作直到装满。对于第n个钱包重复放硬币、左移、右移。
C题题意：有n个人，每个人有一个分数，对于每个人输出一个数（要求不小于其分数），使得这些数互不相等，且总和最小。输出任意一个符合要求的序列。
思路：贪心。记录原序列的分数num和编号id，然后按照num从小到大qsort一遍。开一个数组ans记录答案，同时用一个变量k记录目前答案的最大值。若a[i].num!=a[i-1].num，则b[a[i].id]=max(a[i].num,k+1),否则b[a[i].id]=max(b[a[i-1].id],k+1)。同时将b[a[i].id]的值赋值给k。该算法的正确性不难证明。
D题题意：输入四个整数k,x,n,m,字符串s[1]长度为n，字符串s[2]长度为m。对于字符串s[i](i>2,i∈N)有s[i]=s[i-2]+s[i-1]。求出字符串s1,s2，使得s[k]中含有x个'AC'。输出任意一个答案。
思路：如果不考虑字符串首尾相连所产生的'AC'，那么s[k]中的'AC'数量就只与s[1],s[2]中'AC'的数量有关，枚举s[1],s[2]中的'AC'数量，并用斐波那契数列算出s[k]中的'AC'数量ans1.接下来枚举两个字符串的首尾字母分别是A还是C，通过递推算出额外产生的'AC'数量ans2.如果ans1+ans2=x，则可以根据首尾字母以及'AC'数量构造出相应的字符串，长度不足用其他任意字母补齐即可。如果没有找到方案则输出'Happy new year!'
E题题意：把n张纸片放在直角坐标系上，编号小的放在上面，纸片左下角与原点重合。纸片的横坐标为0到k，横坐标为i的地方纸片上方的纵坐标为a[i]，而纸片下方与x轴重合。求出每张纸片没有被其他纸片覆盖部分的面积。
思路：计算几何。

